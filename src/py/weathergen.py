# read average weather data and generate realistic random weather
import sys
import os
import re

test= "---"

# Error class for reporting errors related to reading weather files
class WeatherError(Exception):
    def __init__(self, value, info=""):
        self.value = value
        self.info = info

# Classes which contain data on the type of file being read - intended for dealing with spreadsheet tables ~~~~~~~~~#


# markers used to delimit rows and cells, and to mark empty cells
class TableDelimiters:
    def __init__(self,
                 cell_border=",",
                 row_border="\n",
                 empty_cell="---",
                 ):
        self.cell_border = re.compile(cell_border)
        self.row_border = re.compile(row_border)
        self.empty_cell = re.compile(empty_cell)


# The type of data in each row, as a comma separated string. Accepts 3 types in this list:
# dt standing for date_type; it standing for integer_type; ft standing for float type.
# Each type is defined by regular expressions; by default "dt" is precisely 4 numeric digits,
# "it" is 0 or more numeric digits, and "ft" is an optional "-" sign followed by 0 or more
# numeric digits followed optionally by a decimal point and more numeric digits.
class DataTypes:
    def __init__(self,
                 types="dt, it, ft, ft, it, ft, ft",
                 date_type=r"[0-9]{4}$",
                 integer_type=r"[0-9]*$",
                 float_type=r"-?[0-9]*\.?[0-9]*$",
                 ):
        self.date_type = re.compile(date_type)
        self.short_type = re.compile(integer_type)
        self.float_type = re.compile(float_type)
        types = types.split(", ")
        self.types = []
        for x in types:
            if x == "dt":
                self.types.append(self.date_type)
            elif x == "it":
                self.types.append(self.short_type)
            elif x == "ft":
                self.types.append(self.float_type)
            else:
                self.types.append([])


# data on the headings and units of the various columns in the file, and the rows in the file
# where this data is stored; also specified is a sort_by column, the value given must match
# one of the values in the headings list.
class Labels:
    def __init__(self,
                 heading_row=None,
                 unit_row=None,
                 data_row=0,
                 headings="yyyy, mm, tmax, tmin, af, rain, sun",
                 units="degC, degC, days, mm, hours",
                 ):
        self.heading_row = heading_row
        self.unit_row = unit_row
        self.data_row = data_row
        self.headings = headings.split(", ")
        self.columns = len(self.headings)
        self.units = units.split(", ")
        self.labels = len(units)


# a wrapper containing all the other three file metadata classes
class FileSettings:
    def __init__(self, delimiters=TableDelimiters(),
                 data_types=DataTypes(),
                 labels=Labels()):
        self.delimiters = delimiters
        self.data_types = data_types
        self.labels = labels

# Functions to read particular types of file ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#


# Reads the Weather gen (wg) files generated by the weather gen programme from UKCP09
# these files follow the naming convention r_<filenumber>_scen_dly.csv where <filenumber>
# is the ID for a given file. They are CSV files where , denotes a new cell and a new
# line denotes a new row of the table. The column headings are stored separately from
# the data.

def read_wg_file(filenumber):
    file_path = "./weatherdata/weathergen/"
    prefix = "r_"
    suffix = "_scen_dly"
    extension = ".csv"
    delim = TableDelimiters(empty_cell="")
    types = DataTypes(types="dt, it, it, it, it, ft, ft, ft, ft, ft, ft, ft, ft, ft")
    lab = Labels(
        headings="year, month, day, day_count, transition, precip_dtotal, temp_dmin, temp_dmax, vapourpressure_dmean, relhum_dmean, sunshine_dtotal, diffradt_dtotal, dirradt_dtotal, pet_dmean",
        units="-, -, -, -, -, mm / day, degC, degC, hPa, %, hours, kWh / m2, kWh / m2, mm / day"
    )
    wg = FileSettings(delimiters=delim, data_types=types, labels=lab)

    file = file_path+prefix+'{0:04d}'.format(filenumber)+suffix+extension
    print(test, file)
    text = open_file(file)
    data = read_file(text, wg)
    data = list(zip(*data))
    data = label(data, lab)
    return data


# reads local weather(lw) from the met office
# these files have 5 lines of explanatory information
# followed by the column headings yyyy mm tmax tmin af rain sun
# followed by the units for each column blank blank degC degC days mm hours
# followed by the data, which may be marked with # or * in some cases, absent data marked ---
def read_lw_file():
    file = choose_file_in_dir()
    text = open_file(file)

    delim = TableDelimiters(cell_border=r"[\s]{2,}", empty_cell=r"---$")
    lab = Labels(heading_row=5, unit_row=6, data_row=7)
    lw = FileSettings(delimiters=delim, labels=lab)
    data = read_file(text, lw)
    sort_col = lab.headings.index("mm")
    data = split_by_values(data, sort_col, [1, 13])
    data = transpose(data, 12)
    return data


# Functions  selecting, reading and parsing the files~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

def choose_file_in_dir(directory="./weatherdata"):
    # Ask the user to select a file from the weatherdata directory
    try:
        files = os.listdir(directory)
    except OSError:
        raise WeatherError("NoDataDirectory")

    num_files = len(files)
    if num_files <= 0:
        raise WeatherError("NoDataFile")

    files.sort()
    print("Please chose a file from the following list (key in the item number): ", end=" ")

    for i in range(0, num_files):
        print("{}.{};".format(i + 1, files[i]), end="  ")
    print("")

    item = 1
    while True:
        try:
            item = int(sys.stdin.readline())
            if not (1 <= item <= num_files):
                print("The value you entered was not valid: please enter a number from 1 to {}".format(num_files))
            else:
                break
        except ValueError:
            print("The value you entered was not an integer: please try entering the item number again")

    filename = files[item - 1]
    print("Thank you - you have selected the data file:", filename)
    return directory + "/" + filename


def open_file(filename):
    try:
        data_file = open(filename, "r")
    except OSError:
        raise WeatherError("FileUnopenable")
    text = data_file.read()
    data_file.close()
    return text


def read_file(text, filetype):
    delimiters = filetype.delimiters
    labels = filetype.labels
    text = remove_markers(text)
    data, rows = split_strip(text, delimiters)
    check_headings(data, labels)
    data, null_count, error_count = check_type(data, filetype, rows)
    data = trim(data, labels)
    report(null_count, error_count, labels)
    return data


def remove_markers(text):
    # remove markers
    markers = "*#"
    for char in markers:
        text = text.replace(char, "")
    return text


def split_strip(text, delimiters):
    # split_by_values the data into a 2D list and strip out whitespace
    text = text.strip()
    data = delimiters.row_border.split(text)
    rows = len(data)
    for i in range(rows):
        data[i] = data[i].strip()
        data[i] = delimiters.cell_border.split(data[i])
    return data, rows


def check_headings(data, labels):
    # check the headings and units meet our expectations
    if labels.heading_row and not data[labels.heading_row][:labels.columns] == labels.headings:
        raise WeatherError("WrongDataHeadings", data[labels.heading_row])
    if labels.unit_row and not data[labels.unit_row][:labels.labels] == labels.units:
        raise WeatherError("WrongDataUnits", data[labels.unit_row])


def check_type(data, filetype, rows):
    # check data and convert to appropriate variable type
    # record of unreadable and null data values

    datatypes = filetype.data_types
    delimiters = filetype.delimiters
    labels = filetype.labels

    null_count = [0] * labels.columns
    error_count = [0] * labels.columns

    for i in range(labels.data_row, rows):
        for j in range(labels.columns):
            if datatypes.types[j].match(data[i][j]) is None:
                if delimiters.empty_cell.match(data[i][j]):
                    null_count[j] += 1
                else:
                    error_count[j] += 1
                data[i][j] = None
            else:
                if datatypes.types[j] == datatypes.float_type:
                    data[i][j] = float(data[i][j])
                else:
                    try:
                        data[i][j] = int(data[i][j])
                    except TypeError:
                        print(data[i[j]])
    return data, null_count, error_count


def trim(data, labels):
    # trim away additional information
    del data[:labels.data_row]
    rows = len(data)
    for i in range(rows):
        data[i] = data[i][:labels.columns]
    return data


def split_by_values(data, sort_col, value_range):
    # sort lists by variable in the sorting column (relies on this value being of integer type)
    # such that for each value within the given range a separate list of lists is created
    # if a value in the rage is not found in the sorting column it will result in an empty list
    data_sorted = [[] for i in range(value_range[0], value_range[1])]
    error_count = 0
    for row in data:
        if value_range[0] <= row[sort_col] < value_range[1]:
            data_sorted[row[sort_col] - value_range[0]].append(row)
        elif row[sort_col]:
            error_count += 1
    if error_count:
        print("Warning:", error_count, "rows were rejected as their values did not fall in the range(",
              value_range[0], ":", value_range[1], ")")
    return data_sorted


def transpose(data, length):
    # transpose columns to make analysis easier
    for i in range(length):
        data[i] = list(zip(*data[i]))
    return data


def report(null_count, error_count, labels):
    # announce success
    print("\nFile has been read successfully; any errors or empty cells are counted below:")
    print("Unreadable values by column:", end="")
    for i in range(labels.columns):
        print(labels.headings[i], "=", error_count[i], end="; ")
    print("\nEmpty cells by column:", end="")
    for i in range(labels.columns):
        print(labels.headings[i], "=", null_count[i], end="; ")
    print("\n")


def label(data, labels):
    labeled_data = {"length": len(data[0]), "units": labels.units, "headings": labels.headings}
    for i in range(labels.columns):
        labeled_data[labels.headings[i]] = data[i]
    return labeled_data

#
# try:
#     print(read_lw_file())
# except WeatherError as err:
#     print(err.value, err.info)
# print("done")
#
# try:
#     data=(read_wg_file(1))
# except WeatherError as err:
#     print(err.value, err.info)
#
# for row in data:
#     for group in row:
#         print(group)
# print("done")
